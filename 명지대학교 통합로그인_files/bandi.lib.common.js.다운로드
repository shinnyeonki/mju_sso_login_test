/*
  [v1.4.6 2023-09-15]
  - withCredentials 옵션 추가
  
  [v1.4.5 2022-10-08] 
  - 로그인 암호화시 한글 처리 서버(1.4.1 이상)
*/
/* 문자열  trim */
if( !String.prototype.trim ) {
    String.prototype.trim = function() { 
        return this.replace(/^\s+|\s+$/g,''); 
    }
}

function isEmptyString(value) {
    if (value === null) return true;
    if (typeof value === 'undefined') return true;
    if (value === '') return true;
    if ( value.trim() === '') return true;
        
    return false;
}

var bandiJS = null;

(function(window, undefined){
    "use strict";
    
    var randomChars ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var randomCharsLength = randomChars.length;
    
    
    function randomLimit(limit) {
        if(window && window.crypto ) {
            var array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            var secureNumber = (array[0]%limit);
            return secureNumber;
        } else {
            return Math.floor(Math.random() * limit);
        }
    }
    
    
    function generateRandom(length) {
        var result = '';
        
        for ( var i = 0; i < length; i++ ) {
            result += randomChars.charAt(randomLimit(randomCharsLength));
        }

        return result;
    }
    
    function uuidV4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = randomLimit(16) | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    function log(msg) {
        if(console && msg) {
            if( console.log) {
                console.log(msg);
            }
        }
    }
    
    function errorLog(msg) {
        if(console ) {
            if( console.error) {
                console.error(msg);
            }else {
                log('error:' + msg);
            }
        }
        
    }
    
    function isHangul(value) {
    
        if(!value) {
            return false;
        }
           
        return /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/.test(value);
        
    }
    
    function isAscii(value) {
        if(!value) {
            return true;
        }
        
        return /^[\x00-\x7F]+$/g.test(value);
    } 
    

    /*    넘어온 값이 빈값인지 체크합니다.    [], {} 도 빈값으로 처리 */
    function isEmpty(value){
        if(  value == undefined ||  value == null || value == "" || 
                ( value != null && typeof value == "object" && !Object.keys(value).length ) ){
            return true
        } else {
            return false
        }
     };



    /* url, method, data, successCallback, errorCallback */
    function ajaxCall(param) {
        
        var url = param.url;
        var method = param.method;
        var data = param.data;
        var successCallback = param.successCallback;
        var errorCallback = param.errorCallback;
        var async = true;
        var timeout = param.timeout;
        if( param && typeof param.async !== 'undefined' && param.async === false) {
            async = false;
        }
        
        /* client withCredentials=true: cookie, Authorization , TLS client certificates */
        /* server : Access-Control-Allow-Credentials = true */ 
        var withCredentials = false;
        if( param && typeof param.withCredentials !== 'undefined' && param.withCredentials === true) {
            withCredentials = true;
        }
        
        /* method = GET, POST */
        var request = new XMLHttpRequest();
        request.open(method, url, async);
        request.withCredentials = withCredentials;
        
        if( async && timeout && timeout > 500) {
            /* async= false timeout 설정 불가 */
            request.timeout = timeout;
            
            request.addEventListener("timeout", function(e) {
                errorCallback('request.timeout', 0);
            });
            
        } 
        
        if( method && 'POST' == method.toUpperCase() ) {
            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
        } 
        
        request.onload = function() {
        
            if (this.status === 200 || this.status === 201 ) {
                /* Success! */
                if( successCallback ) {
                    successCallback( this.response, this.status);
                }
            
            } else {
                /* We reached our target server, but it returned an error */
                if( errorCallback ) {
                    errorCallback( this.response, this.status);
                }
            }
        };

        request.onerror = function() {
            if( errorCallback ) {
                errorCallback( 'request.onerror', 0);
            }
        };
        
        if( data ) {
            var sendData = '';
            for (var key in data) {
                if( sendData != '' ) {
                    sendData += '&';
                }
                
                sendData += key +'=' + encodeURIComponent(data[key]);
            }
        
            request.send(sendData);
        } else {
            request.send(null);
        }
        
    }
    
    var crypt = {
        setPublicKey: function( publicKeyStr ) {
            publicKeyStr = publicKeyStr.replace(/ /gi, "+");
            this.publicKey = forge.pki.publicKeyFromPem('-----BEGIN PUBLIC KEY-----\n'+publicKeyStr+'\n-----END PUBLIC KEY-----');
        },
        encryptPKI: function (value, rsaType) {
            return this.encryptBytesPKI(forge.util.encodeUtf8(value), rsaType);
        },
        encryptBytesPKI: function (bytes, rsaType) {
            if( !rsaType ) {
                rsaType = 'RSA-OAEP'; /* magic rsa */
                
                /* default java rsa 'RSAES-PKCS1-V1_5' */
            }
        
            var value = this.publicKey.encrypt(bytes, rsaType, {
                  md: forge.md.sha256.create()
            }); 
            
            return forge.util.encode64(value);
        },
        genKey: function(length) {
            
            var keyStr = forge.util.encode64(forge.random.getBytesSync(64));
            var salt = keyStr.substring( keyStr.length - 16);

            var keyBytes = forge.pkcs5.pbkdf2(keyStr, salt, 1024, length);
            var ivBytes = keyBytes.slice(keyBytes.length - 16);
            return {
                length: length,
                key: keyBytes,
                iv: ivBytes,
                keyStr:keyStr
            };
        }, 
        deleteKey: function(keyInfo) {
            if( keyInfo ) {
                delete keyInfo.key;
                delete keyInfo.iv;
                delete keyInfo.keyStr;
                keyInfo = null;
            }
        },
        encryptAES: function(value, keyInfo) {
            var uriEncValue = encodeURIComponent(value);
            var cipher = forge.cipher.createCipher('AES-CBC', keyInfo.key);
            cipher.start({iv:keyInfo.iv});
            cipher.update(forge.util.createBuffer(uriEncValue));
            cipher.finish();
            
            return forge.util.encode64(cipher.output.bytes());
        },
        decryptAES: function(encValue, keyInfo) {
            var dec64Value = forge.util.decode64(encValue);
            
            var cipher = forge.cipher.createDecipher('AES-CBC',keyInfo.key);
            cipher.start({iv:keyInfo.iv});
            cipher.update(forge.util.createBuffer(dec64Value));
            cipher.finish();
            
            return decodeURIComponent(cipher.output.data);
        },
        encryptBase64AES: function(value, keyInfo, isEncodeUri, isUtf8) {
            var encValue = value;

            if( !isAscii(value)) {
                /* 아스키 문자가 아닌경우 경우 */
                encValue = encodeURIComponent('__h_' + value);
            } else if( isEncodeUri ) {
                encValue = encodeURIComponent(value);
            }

            var enc64Value = null ;
            if( isUtf8) {
                enc64Value = forge.util.encodeUtf8(encValue);
            } else {
                enc64Value = forge.util.encode64(encValue);
            }
            
            var cipher = forge.cipher.createCipher('AES-CBC', keyInfo.key);
            cipher.start({iv:keyInfo.iv});
            cipher.update(forge.util.createBuffer(enc64Value));
            cipher.finish();
            
            return forge.util.encode64(cipher.output.bytes());
        },
        decryptBase64AES: function(encValue, keyInfo, isEncodeUri, isUtf8) {
            var dec64Value = forge.util.decode64(encValue);
            
            var cipher = forge.cipher.createDecipher('AES-CBC',keyInfo.key);
            cipher.start({iv:keyInfo.iv});
            cipher.update(forge.util.createBuffer(dec64Value));
            cipher.finish();
            
            var decValue = null;
            if( isUtf8) {
                decValue = forge.util.decodeUtf8(cipher.output.bytes());
            } else {
                decValue = forge.util.encode64(cipher.output.bytes());
            }
            
            if( isEncodeUri ) {
                return decodeURIComponent(decValue);
            } else {
                return decValue;
            }
        }
        
    };

    var bandiInnerJS = {
        isDebug: false,
        
        log: function(msg) {
            if(this.isDebug) {
                log(msg);
            }
        },
        errorLog: function(msg) {
            if(this.isDebug) {
                errorLog(msg);
            }
        },
        setPublicKey: function( publicKeyStr ) {
            crypt.setPublicKey(publicKeyStr);
        },
        encryptPKI: function (value) {
            return crypt.encryptPKI(value);
        },
        encryptBytesPKI: function (bytes) {
            return crypt.encryptBytesPKI(bytes);
        },
        encryptJavaPKI: function (value) {
            return crypt.encryptPKI(value, 'RSAES-PKCS1-V1_5');
        },
        encryptJavaBytesPKI: function (bytes) {
            return crypt.encryptBytesPKI(bytes, 'RSAES-PKCS1-V1_5');
        },
        genKey: function(length) {
            return crypt.genKey(length);
        }, 
        deleteKey: function(keyInfo) {
            crypt.deleteKey(keyInfo);
        },
        encryptAES: function(value, keyInfo) {
            return crypt.encryptAES(value, keyInfo);
        },
        decryptAES: function (encValue, keyInfo) {
            return crypt.decryptAES(encValue, keyInfo);
        },
        encryptBase64AES: function (encValue, keyInfo, isEncodeUri, isUtf8) {
            return crypt.encryptBase64AES(encValue, keyInfo, isEncodeUri, isUtf8);
        },
        decryptBase64AES: function (encValue, keyInfo, isEncodeUri, isUtf8) {
            return crypt.decryptBase64AES(encValue, keyInfo, isEncodeUri, isUtf8);
        },
        generateRandom: function(length) {
            return generateRandom(length);
        },
        uuidV4: function() {
            return uuidV4();
        },
        newTabId: function() {
            var id = generateRandom(64);
            sessionStorage.setItem("p_bds_kidb", id);
            return id;
        },
        getTabId: function() {
            return sessionStorage.getItem("p_bds_kidb");
        },
        checkTabId: function(tabId){
            var savedId = sessionStorage.getItem("p_bds_kidb");
            
            if( !tabId || !savedId) {
                return false;
            }
            
            return tabId == savedId;
        }, 
        isHangul: function(value){
            return isHangul(value);
        },
        isAscii: function(value){
            return isAscii(value);
        },
        ajax: function(param) {
            ajaxCall(param);
        },
        ajaxPost: function(url, data, successCallback, errorCallback, withCredentials) {
            var wcValue = false;
            if( typeof withCredentials !== 'undefined' && withCredentials === true) {
                wcValue = true;
            }
            
            var param ={
                url: url,
                method: 'POST',
                data: data,
                successCallback: successCallback,
                errorCallback: errorCallback,
                withCredentials: wcValue 
            };
            
            this.ajax(param);
        },
        ajaxGet: function(url, successCallback, errorCallback, withCredentials) {
            var wcValue = false;
            if( typeof withCredentials !== 'undefined' && withCredentials === true) {
                wcValue = true;
            } 
            
            var param ={
                url: url,
                method: 'GET',
                successCallback: successCallback,
                errorCallback: errorCallback,
                withCredentials: wcValue 
            };
            
            this.ajax(param);
        }
    };

    bandiJS = bandiInnerJS;
})( window );



(function(window, undefined){
    "use strict";
    var isDebug = false;
    var agentUrl = 'http://localhost';
    var serverPort = 0;
    var initPort = 13750;
    var publicKeyStr = '';
    var isAgentAlive = false;
    var defaultTimeout = 5000;

    function getAgentUrl(url) {
        var port = serverPort == 0 ? initPort : serverPort;
            
        return agentUrl +':' + port + url;  
    }
    
    function agentInit(param) {
        if(!param) return;
        
        if( param.serverPort ) {
            serverPort = param.serverPort;
        }
        
        if( param.isDebug && param.isDebug === true ) {
            isDebug = true;
            bandiJS.isDebug = true;
        }
        
    }
    
    function log(msg) {
        if( isDebug ) {
            bandiJS.log(msg);
        }
    }
    
    function errorLog(msg) {
        
        if( isDebug ) {
            bandiJS.errorLog(msg);
        }
    }
    
    function encrypt(data, keyInfo) {
        try {
            var encData = {};
            
            if(data.pw) {
                /* url encoding 대문에 비밀번호만 다시 암호화 */
                data.pw = bandiJS.encryptBase64AES(data.pw, keyInfo, false, false);
            }
            
            bandiJS.setPublicKey(publicKeyStr);
            encData.encsymka = bandiJS.encryptJavaPKI(keyInfo.keyStr);
            if (data) {
                encData['enc_d_a'] = bandiJS.encryptBase64AES(JSON.stringify(data), keyInfo, true, true);
            }

            return encData;
        } catch (e) {
            errorLog(e);
        } 
    }
    
    function defaultSuccessCallback(response, status, successCallback) {
        
        if( response !== null && typeof response === 'object') {
            bandiJS.log('response:' + JSON.stringify(response));
        } else {
            bandiJS.log('response:' + response);
        }
        
        bandiJS.log('status:' + status);
        
        
        if( successCallback ) {
            successCallback(response, status);
        }
    }
    
    function defaultErrorCallback(response, status, errorCallback) {
        
        if( response !== null && typeof response === 'object') {
            bandiJS.errorLog('response:' + JSON.stringify(response));
        } else {
            bandiJS.errorLog('response:' + response);
        }
        
        bandiJS.errorLog('status:' + status);
     
        if( status == 0 ) {
            if( !errorCallback ) {
                alert('Agent is off!, turn on Agent!');
            } else {
                
                if( response && response.error   ) {
                    if( 'NetworkError' == response.error ) {
                        errorCallback({
                            success: false,
                            error: 'agent.is.off',
                            statusCode: 500
                        }, status);
                    } else {
                        errorCallback({
                            success: false,
                            error: response.error,
                            statusCode: 500
                        }, status);
                    }
                }
                
            }
            
            return;
        } 
        
        if( !errorCallback ) {
            if( response && response.error) {
                alert(response.error);
            }
                
        } else {
            errorCallback(response, status);
        }
        
    }
    
    function decrypt(response, keyInfo) {
        try {
            if (response && response.dataMap && response.dataMap.enc_d_a) {
                var decryptData = bandiJS.decryptBase64AES(response.dataMap.enc_d_a, keyInfo, true, true);
                response.dataMap = JSON.parse(decryptData);
            }
            
            return response;
        } catch (e) {
            errorLog(e);
        } finally {
            bandiJS.deleteKey(keyInfo);
        }
    }
    
    
    function encryptPost(url, requestType, data, successCallback, errorCallback, timeout) {
        
        if( !timeout || timeout < 1) {
            timeout = defaultTimeout;
        }
        
        var keyInfo = bandiJS.genKey(32);
        
        var encData = encrypt(data, keyInfo);
        encData['request_app'] = 'WEB';
        encData['request_type'] = requestType;
       
        bandiJS.ajax({
            url: getAgentUrl(url),
            method: 'post',
            data: encData,
            successCallback: function (response, status) {
                var decryptResponse = decrypt(JSON.parse(response), keyInfo);
                
                if(keyInfo) {
                    bandiJS.deleteKey(keyInfo);
                }
                
                defaultSuccessCallback(decryptResponse, status, successCallback);
                
            },
            errorCallback: function (response, status) {
                var error = 'error';
                try{
                    var errorResponse = JSON.parse(response);
                    error = errorResponse.error;
                } catch(e) {
                    error = response;
                }
                
                if(keyInfo) {
                    bandiJS.deleteKey(keyInfo);
                }

                defaultErrorCallback({
                    success: false,
                    error: error,
                    statusCode: 500
                }, status, errorCallback);
            },
            async: true,
            timeout: timeout
        });
    }
   
    function agentAlive(successCallback, errorCallback) {
        if (isAgentAlive === true && publicKeyStr) {
            return successCallback({
                success: true,
                statusCode: 200
            }, 200);
        }

        try {
            bandiJS.ajax({
                url: getAgentUrl('/call'),
                method: 'post',
                data: {
                    request_app: 'WEB',
                    request_type: 'agent_alive'
                },
                successCallback: function (response, status) {
                    
                    try{
                        var responseObj = JSON.parse(response);
                        if (!responseObj.success) {
                            errorCallback(response, status);
                            throw 'error';
                        }
                        
                        publicKeyStr = responseObj.dataMap.rserpubk;
                        isAgentAlive = true;
                        
                        defaultSuccessCallback({
                                success: true,
                                statusCode: 200
                            }, status, successCallback);
                
                    } catch(e) {
                        
                        bandiJS.errorLog('response:' + response);
                        
                        defaultErrorCallback({
                            success: false,
                            error: 'response.data.is.not.valid',
                            statusCode: 500
                        }, status, errorCallback);
                    }
                    
                },
                errorCallback: function (response, status) {
                   
                   var error = 'server.is.not.alive';
                   if (response && typeof response === 'string') {
                        error = response;
                   }
                    
                   defaultErrorCallback({
                            success: false,
                            error: error,
                            statusCode: 500
                        }, status, errorCallback);
                    
                },
                async: false
            });
        } catch (e) {
            
            var error = 'NetworkError';
            
            if (e && e.name) error = e.name;
           
            defaultErrorCallback({
                    success: false,
                    error: error,
                    statusCode: 500
                }, 0, errorCallback);
        }
    }
    
    function agentIsLogin(isShownLoginForm, withUserInfo, successCallback, errorCallback) {
        agentAlive(
            function (response, status) {
                
                var data = {
                    is_shown_form: isShownLoginForm,
                    with_user_info: withUserInfo,
                    enc_tt_: new Date().getTime().toString()
                };
                encryptPost('/call', 'check_login', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
       );
    }

    function agentLogin(userId, pw, withUserInfo, successCallback, errorCallback) {
        withUserInfo = withUserInfo || 'N';
        agentAlive(
            function (response, status) {
                var data = {
                    user_id: userId,
                    pw: pw,
                    with_user_info: withUserInfo,
                    enc_tt_: new Date().getTime().toString()
               };
            
                encryptPost('/call', 'login', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
       );

    }
    
    function agentLogout(successCallback, errorCallback) {
        
        agentAlive(
            function (response, status) {
                var data = {
                    enc_tt_: new Date().getTime().toString()
                };
                encryptPost('/call', 'logout', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
        );
        
    }
    
    function agentUserInfo(successCallback, errorCallback) {
        
        agentAlive(
            function (response, status) {
                var data = {
                    enc_tt_: new Date().getTime().toString()
                };
                encryptPost('/call', 'userinfo', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
        );
        
    }
    
    function agentApplySid(sid, successCallback, errorCallback) {
        
        agentAlive(
            function (response, status) {
                var data = {
                    p_sid: sid,
                    enc_tt_: new Date().getTime().toString()
                };
                encryptPost('/call', 'apply_sid', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
        );
    } 
    
    function agentMcpNetworkInfo(isCollectAll, isSendToServer , successCallback, errorCallback) {
        
        agentAlive(
            function (response, status) {
                var data = {
                    isCollectAll: isCollectAll,
                    isSendToServer: isSendToServer,
                    enc_tt_: new Date().getTime().toString()
                };
                encryptPost('/call', 'mcp_network_info', data, successCallback, errorCallback);
            },
            function (response, status) {
                if (errorCallback) {
                    errorCallback(response, status)
                }
            }
        );
        
    }    
        
    var agentInner = {
        init: function(param) {
            
            if( param ) {
                agentInit(param);
            }
        },
        
        alive: function (param) {
            agentAlive(param.successCallback, param.errorCallback);
        },
        
        isLogin: function (param) {
            var isShownLoginForm = param.isShownLoginForm || 'N';
            var withUserInfo = param.withUserInfo || 'N';
            
            agentIsLogin(isShownLoginForm, withUserInfo, param.successCallback, param.errorCallback);
        },
        
        login: function (param) {
            var withUserInfo = param.withUserInfo || 'N';
            agentLogin(param.userId, param.pw, withUserInfo, param.successCallback, param.errorCallback);
        },

        logout: function (param) {
            agentLogout(param.successCallback, param.errorCallback);
        },
        
        userInfo: function (param) {
            agentUserInfo(param.successCallback, param.errorCallback);
        },
        
        applySid: function (param) {
            agentApplySid(param.sid, param.successCallback, param.errorCallback);
        },
        
        mcpNetworkInfo: function (param) {
            var isCollectAll = false;
            var isSendToServer = false;
            if (param.isCollectAll && (param.isCollectAll === 'true' || param.isCollectAll === true)) {
                isCollectAll = true;
            }

            if (param.isSendToServer && (param.isSendToServer === 'true' || param.isSendToServer === true)) {
                isSendToServer = true;
            }

            agentMcpNetworkInfo(isCollectAll, isSendToServer, param.successCallback, param.errorCallback);
        },
        
        call: function(param) {
            
            if( !param || !param.requestType) {
                bandiJs.errorLog("param.requestType is null.");
                return ;
            }
            var requestType = param.requestType; 
            
            if('agent_alive' == requestType) {
                this.alive(param);
            } else if('login' == requestType) {
                this.login(param);
            } else if('logout' == requestType) {
                this.logout(param);
            } else if('userinfo' == requestType) {
                this.userInfo(param);
            } else if('check_login' == requestType) {
                this.isLogin(param);
            } else if('apply_sid' == requestType) {
                this.applySid(param);
            } else if('mcp_network_info' == requestType) {
                this.mcpNetworkInfo(param);
            }
            
        }
        
        
    }   

    
    bandiJS.agent = agentInner;
})( window );
