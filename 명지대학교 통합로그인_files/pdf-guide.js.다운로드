// 이용안내 클릭 시 PDF 모달 표시 및 위치 계산
(function(){
    const trigger = document.querySelector('.notice .pdf_guide');
    const dialog = document.getElementById('pdfGuideDialog');
    const closeBtn = document.getElementById('pdfGuideClose');
    const container = document.getElementById('pdfGuideContainer');
    const header = dialog.querySelector('.pdf-guide-header');
    const loginBox = document.querySelector('.login_box');
    const modalBox = document.querySelector('.modal_box');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const downloadBtn = document.getElementById('pdfDownloadBtn');
    const pdfUrl = '/custom/pdf/file/명지대학교 2차인증 시행 안내 v2.pdf'; // 같은 디렉터리 가정
    // 초기 표시할 페이지(1부터 시작). 필요 시 값을 변경해 사용하세요.
    let initialPageIndex = 1;
    let pdfDoc = null; // 캐시
    function defaultScale(){ return (window.innerWidth <= 768) ? 0.8 : 1.4; }
    let currentScale = defaultScale();

    function hideDialog(){
        if(dialog.open) dialog.close();
        dialog.style.display = 'none';
    }

    function preventEsc(e){ e.preventDefault(); }
    dialog.addEventListener('cancel', preventEsc); // ESC 닫힘 방지

    function clampScale(v){
        if(!Number.isFinite(v)) v = currentScale;
        return Math.min(3, Math.max(0.5, v));
    }

    function updateDisplay(){
        zoomDisplay.textContent = Math.round(currentScale * 100) + '%';
    }

    async function ensurePdf(){
        if(pdfDoc) return pdfDoc;
        const loadingTask = pdfjsLib.getDocument({ url: encodeURI(pdfUrl) });
        pdfDoc = await loadingTask.promise;
        return pdfDoc;
    }

    async function renderPdf(scale){
        if(!window.pdfjsLib){ container.innerHTML='<p style="color:#c00;font-size:13px;">PDF.js 로드 실패</p>'; return; }
        try {
            currentScale = clampScale(scale);
            updateDisplay();
            // --- Capture current view (page + relative offset) before clearing ---
            let restoreInfo = null;
            (function captureCurrent(){
                const canvases = container.querySelectorAll('canvas');
                if(!canvases.length) return; // first render
                const scrollTop = container.scrollTop;
                const mid = scrollTop + container.clientHeight/2;
                let target = null;
                canvases.forEach(cv => {
                    const top = cv.offsetTop;
                    const bottom = top + cv.offsetHeight;
                    if(!target && mid >= top && mid < bottom){ target = cv; }
                });
                if(!target){
                    // fallback: last canvas above scrollTop
                    canvases.forEach(cv => { if(cv.offsetTop <= scrollTop) target = cv; });
                }
                if(!target) return;
                const offsetInside = scrollTop - target.offsetTop;
                const ratio = Math.max(0, Math.min(1, offsetInside / target.offsetHeight));
                const pageIndex = Array.prototype.indexOf.call(canvases, target) + 1;
                restoreInfo = { pageIndex, ratio };
            })();

            container.innerHTML = '<p style="font-size:13px;color:#555;">로딩 중…</p>';
            const pdf = await ensurePdf();
            container.innerHTML='';
            let restoreCanvas = null;
            for(let p=1;p<=pdf.numPages;p++){
                const page = await pdf.getPage(p);
                const viewport = page.getViewport({ scale: currentScale });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width; canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({ canvasContext: ctx, viewport }).promise;
                container.appendChild(canvas);
                if(restoreInfo && p === restoreInfo.pageIndex){ restoreCanvas = canvas; }
            }
            // Restore scroll position near previous view
            if(restoreInfo && restoreCanvas){
                const offset = restoreCanvas.offsetTop + restoreInfo.ratio * restoreCanvas.height;
                container.scrollTop = Math.max(0, Math.min(offset, container.scrollHeight - container.clientHeight));
            } else if (!restoreInfo) {
                // 첫 렌더 또는 이전 컨텍스트 없음: 초기 페이지로 스크롤
                const startPage = Math.min(Math.max(1, initialPageIndex|0), pdf.numPages);
                const target = container.querySelectorAll('canvas')[startPage - 1];
                if (target) {
                    container.scrollTop = Math.max(0, Math.min(target.offsetTop, container.scrollHeight - container.clientHeight));
                }
            }
        } catch(err){
            console.error(err);
            container.innerHTML = '<p style="color:#c00;font-size:13px;">PDF 로드 실패: '+(err.message||String(err))+'</p>';
        }
    }

    function positionDialog(){
		var positionBox = loginBox;
        if(!loginBox) {
			positionBox = modalBox;
		}
		if(!positionBox) return;
        // Mobile: use 5% margins; Desktop: align to login_box right -350px
        if(window.innerWidth <= 768){
            dialog.style.left = '5%';
            dialog.style.top = '5vh';
        } else {
            const rect = positionBox.getBoundingClientRect();
            dialog.style.left = (rect.right - 350) + 'px';
            // top is set by CSS (10vh) unless dragged later
        }
    }

    function openDialog(){
        positionDialog();
        // 표시 복구 후 비모달로 표시(포커스 잃으면 숨김 처리 가능)
        dialog.style.display = '';
        if(typeof dialog.show === 'function'){ dialog.show(); }
        else { dialog.setAttribute('open',''); }
        dialog.focus();
        // 첫 렌더 시 플랫폼별 기본 배율 적용
        if(!container.querySelector('canvas')){
            currentScale = defaultScale();
            updateDisplay();
        }
        renderPdf(currentScale);
    }

    if(trigger){ trigger.style.cursor='pointer'; trigger.addEventListener('click', openDialog); }
    if(closeBtn){ closeBtn.addEventListener('click', hideDialog); }
    if(zoomInBtn){
        zoomInBtn.addEventListener('click', ()=>{
            if(!dialog.open) return;
            renderPdf(currentScale + 0.1);
        });
    }
    if(zoomOutBtn){
        zoomOutBtn.addEventListener('click', ()=>{
            if(!dialog.open) return;
            renderPdf(currentScale - 0.1);
        });
    }
    if(downloadBtn){
        const safeFileName = (name)=>{
            try {
                // 간단한 파일명 정리: 슬래시 제거, 공백은 _로
                return (name || 'document.pdf').replace(/[\\/:*?"<>|]+/g, '').replace(/\s+/g, '_');
            } catch { return 'document.pdf'; }
        };

        async function downloadPdf(){
            const url = encodeURI(pdfUrl);
            const fileName = safeFileName(url.split('/').pop());
            try {
                // Blob 방식: 모바일/웹뷰에서도 동작 가능성 높음 (동일 출처 권장)
                const res = await fetch(url, { credentials: 'same-origin' });
                if(!res.ok) throw new Error('HTTP '+res.status);
                const blob = await res.blob();
                const objectUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = objectUrl;
                a.download = fileName || 'document.pdf';
                document.body.appendChild(a);
                a.click();
                setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 0);
            } catch(err){
                console.warn('Blob 다운로드 실패, 대체 경로 시도:', err);
                // 대체: 새 탭/뷰어로 열기 (iOS Safari 등에서 사용자가 저장 가능)
                const a = document.createElement('a');
                a.href = url;
                a.target = '_blank';
                a.rel = 'noopener';
                document.body.appendChild(a);
                a.click();
                a.remove();
            }
        }

        downloadBtn.addEventListener('click', (e)=>{
            e.preventDefault();
            downloadPdf();
        });
    }
    // 초기 표시
    updateDisplay();

    // 포커스를 잃으면 숨김 처리
    dialog.addEventListener('focusout', (e)=>{
        // relatedTarget가 다이얼로그 내부가 아니면 숨김
        const rt = e.relatedTarget;
        if(!rt || !dialog.contains(rt)){
            hideDialog();
        }
    }, true);

    // -------- Drag Scroll (Pan) inside PDF Container --------
    let isPanning = false, panStartX = 0, panStartY = 0, startScrollLeft = 0, startScrollTop = 0;
    container.addEventListener('mousedown', (e)=>{
        if(e.button !== 0) return; // left only
        isPanning = true;
        container.classList.add('dragging');
        panStartX = e.clientX; panStartY = e.clientY;
        startScrollLeft = container.scrollLeft; startScrollTop = container.scrollTop;
        e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
        if(!isPanning) return;
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        container.scrollLeft = startScrollLeft - dx;
        container.scrollTop = startScrollTop - dy;
    });
    window.addEventListener('mouseup', ()=>{
        if(isPanning){ isPanning = false; container.classList.remove('dragging'); }
    });

    // Touch support
    container.addEventListener('touchstart', (e)=>{
        if(e.touches.length!==1) return;
        const t = e.touches[0];
        isPanning = true;
        panStartX = t.clientX; panStartY = t.clientY;
        startScrollLeft = container.scrollLeft; startScrollTop = container.scrollTop;
    }, {passive:true});
    container.addEventListener('touchmove', (e)=>{
        if(!isPanning || e.touches.length!==1) return;
        const t = e.touches[0];
        const dx = t.clientX - panStartX;
        const dy = t.clientY - panStartY;
        container.scrollLeft = startScrollLeft - dx;
        container.scrollTop = startScrollTop - dy;
    }, {passive:true});
    container.addEventListener('touchend', ()=>{ isPanning = false; });

    // -------- Draggable Dialog (Header) --------
    let draggingDialog = false, dlgStartX = 0, dlgStartY = 0, dlgOrigLeft = 0, dlgOrigTop = 0;
    header.addEventListener('mousedown', (e)=>{
        // Ignore clicks on buttons/zoom controls
        if(e.target.closest('.zoom-controls') || e.target === closeBtn) return;
        draggingDialog = true;
        dlgStartX = e.clientX; dlgStartY = e.clientY;
        const rect = dialog.getBoundingClientRect();
        dlgOrigLeft = rect.left; dlgOrigTop = rect.top;
        e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
        if(!draggingDialog) return;
        const dx = e.clientX - dlgStartX;
        const dy = e.clientY - dlgStartY;
        dialog.style.left = (dlgOrigLeft + dx) + 'px';
        dialog.style.top = (dlgOrigTop + dy) + 'px';
    });
    window.addEventListener('mouseup', ()=>{ draggingDialog = false; });
})();