현재 명지대학교 SSO 시스템은 보안 수준이 상당히 높은 **금융권 수준의 하이브리드 암호화 및 세션 관리** 방식을 사용하고 있습니다.

복잡해 보이지만, **"내가 보낸 비밀번호를 해커가 중간에서 절대 가로챌 수 없게 하고(암호화), 내가 로그인한 척하는 다른 사람을 막겠다(세션/CSRF)"**는 것이 핵심 목표입니다.

각 요소가 왜 필요한지, 그리고 전체적인 보안 그림을 하나씩 풀어드리겠습니다.

---

### 1. 암호화 키 (Key): "봉투 안에 봉투 넣기"

질문하신 **공개키/비공개키**는 **RSA(비대칭키)** 방식입니다. 하지만 이 시스템은 **AES(대칭키)** 방식도 섞어 씁니다. 왜냐하면 RSA는 보안성은 좋지만 속도가 느리고, 긴 데이터(비밀번호 등)를 암호화하기 어렵기 때문입니다.

#### ① 공개키 (Public Key) - 서버가 줌
*   **역할:** **"잠그는 자물쇠"**입니다.
*   **작동:** 서버는 접속하는 모든 사람(Client)에게 이 공개키를 뿌립니다. 해커가 이걸 가져가도 상관없습니다. 이 키로는 **잠글 수만 있고, 열 수는 없기 때문**입니다.
*   **용도:** 클라이언트가 만든 **'임시 세션키(AES키)'를 잠글 때** 사용합니다.

#### ② 비공개키 (Private Key) - 서버만 가짐
*   **역할:** **"여는 열쇠"**입니다.
*   **작동:** 서버 깊숙한 곳에 숨겨져 있으며 절대 밖으로 나가지 않습니다.
*   **용도:** 클라이언트가 공개키로 잠가서 보낸 **'임시 세션키'를 풀 때** 사용합니다.

#### ③ 세션키 (Session Key / AES Key) - 클라이언트가 만듦 (중요!)
*   **역할:** **"비밀번호를 잠그는 진짜 열쇠"**입니다.
*   **작동:** 브라우저(또는 파이썬)가 로그인 버튼을 누를 때마다 랜덤하게 생성합니다. (매번 바뀜)
*   **용도:** 실제 **비밀번호**는 이 키로 암호화합니다.

> **💡 전체 시나리오 (하이브리드 암호화)**
> 1.  (Client) 랜덤한 **'세션키'**를 하나 만든다.
> 2.  (Client) **'세션키'**로 **[비밀번호]**를 암호화한다. (빠른 AES 암호화)
> 3.  (Client) 서버가 준 **'공개키'**로 **[세션키]** 자체를 암호화한다. (안전한 RSA 암호화)
> 4.  (Client) 이 두 덩어리를 서버로 보낸다.
>
> **결과:** 해커가 중간에 패킷을 훔쳐도, '공개키'로 잠긴 '세션키'를 못 풀기 때문에, 그 안에 있는 '비밀번호'도 절대 풀 수 없습니다.

---

### 2. 쿠키 (Cookie): "방문증 및 신원확인"

HTTP 통신은 기본적으로 **건망증**이 심합니다. 요청 하나를 보내고 나면, 서버는 당신이 누구였는지 즉시 잊어버립니다. 이를 기억하기 위해 쿠키를 사용합니다.

#### ① JSESSIONID (Java Session ID)
*   **정체:** 톰캣(Tomcat, 자바 웹 서버)이 발급하는 **"임시 방문증"**입니다.
*   **목적:** **"이 요청을 보낸 사람이 아까 그 페이지에 들어왔던 그 사람인가?"**를 식별합니다.
*   **상황:**
    1.  처음 로그인 페이지에 접속(GET)하면 서버가 `JSESSIONID=ABC...`를 발급합니다.
    2.  로그인 정보 전송(POST)할 때 이 쿠키를 같이 안 보내면, 서버는 "넌 누군데 갑자기 아이디를 던지니?" 하고 거부합니다.
    3.  로그인 성공 후에도 "나 아까 로그인 성공한 사람이야"라고 증명하는 용도로 계속 쓰입니다.

#### ② bandisncdevid (Bandi Device ID)
*   **정체:** 명지대가 사용하는 보안 솔루션(Bandi)이 생성한 **"기기 식별 고유번호"**입니다.
*   **목적:** **중복 로그인 방지 및 보안 감지**
*   **작동 원리:**
    *   사용자의 브라우저 정보, IP 등을 조합해서 고유한 ID를 만듭니다.
    *   만약 해커가 `JSESSIONID`를 훔쳐서 다른 컴퓨터에서 접속을 시도하더라도, `bandisncdevid`가 바뀌거나 매칭되지 않으면 차단하기 위함입니다. "어? 아까 로그인하던 컴퓨터랑 다른데?" 하고 잡아내는 역할입니다.

---

### 3. 기타 토큰 (Token): "위조 방지"

#### ① c_r_t (CSRF Token)
*   **정체:** Cross-Site Request Forgery 방지 토큰입니다.
*   **목적:** **가짜 로그인 창 방지**
*   **상황:** 해커가 가짜 사이트를 만들어 놓고 "여기서 로그인하세요"라고 할 수 있습니다. 하지만 해커의 가짜 사이트에는 명지대 서버가 발급한 오늘의 암구호(`c_r_t`)가 없습니다. 서버는 이 값이 없으면 요청을 무시합니다.

---

### 📝 요약: 로그인 한 번에 일어나는 일

1.  **접속 (GET):**
    *   서버: "어서오세요. 방문증(`JSESSIONID`) 가지시고, 기기등록(`bandisncdevid`) 하세요. 그리고 암호화용 자물쇠(`공개키`)와 암구호(`c_r_t`) 드립니다."
    *   클라이언트: (모두 저장)

2.  **준비 (Client Internal):**
    *   클라이언트: "일회용 열쇠(`세션키`)를 만들자."
    *   클라이언트: "일회용 열쇠로 `비밀번호`를 잠그자(AES)."
    *   클라이언트: "일회용 열쇠 자체를 서버가 준 자물쇠(`공개키`)로 잠그자(RSA)."

3.  **전송 (POST):**
    *   클라이언트: "방문증(`Cookie`), 암구호(`c_r_t`), 잠긴 비밀번호, 잠긴 열쇠 봉투를 제출합니다."

4.  **검증 (Server):**
    *   서버: "`비공개키`로 열쇠 봉투를 열어서 `세션키` 획득! 그 `세션키`로 `비밀번호` 획득! DB랑 일치하네? 방문증도 맞고 암구호도 맞네. **로그인 승인!**"

이 모든 과정이 **Client(브라우저/코드)**와 **Server** 간에 약속된 규약대로 1바이트라도 틀림없이 수행되어야 로그인이 성공합니다.